\chapter{Squiggles Alignment}

\label{kap:squiggles} % id kapitoly pre prikaz ref

In this chapter we describe our work. We took a different approach to composing DNA sequence from multiple squiggles. 
We took squggles that correspond to the same part of refference sequence and aligned them together to produce one signal 
that will be basecalled. We designed several ways of multiple squggles alignment to generate signal most similar to the ideal signal.

\section{Squiggles and preprocessing}

MinION device produces a sequences of measured values of current passing a nanopore. We call this sequences a squiggles.
Typically we have multiple squiggles covering each part of the DNA. Raw signal contain values in pA between $0$ and several hundreds. 
This values have consistent deviation in single read but can be shifted in different read. 

The best way to hide this differences is to scale the sequence such that resulting mean value is 0 and standard deviation is 1.
TODO refference Kubo H.

\section{Squiggles alignment with Dynamic Time Warping}
To align two squiggles we use method called Dynamic Time Warping (DTW).
DTW is widely used in audio processing and speech recognition.
It uses a similar approach as Needleman-Wunsh algorithm for sequence alignment but does not specify match or mismatch.

\subsection{Dynamic Time Warping}

We define a cost function $c(i,j)$ which tells us price for aligning value $i$ to value $j$. 
It can be for example euclidean distance $abs(i-j)$.

By evaluating cost function for two sequences $u$ and $v$, we calculate a cost matrix $C$ where $C[i,j]=c(u_i,v_j)$.
The best alignment of this two sequences can be represented as a continuous path from $C[1,1]$ to $C[n,m]$ with lowest sum of costs. 
We call such path a warping path. The sum of costs on such path also tells us the similarity of those sequences.


\begin{figure}
  \centering
  TODO
  %\includegraphics[width=0.5\textwidth]{gull}
  \caption{obrazok na ktorom je warping path}
\end{figure}

The warping path can be represented as a list of coordinates from matrix $C$.


\subsection{Implementation}
To find the best path, we will actually not compute matrix $C$ with costs of aligning single values.
Instead, we will calculate matrix $A$ where $A[i,j]$ contains value of warping path of sequences $u_1...u_i$ and $v_1...v_j$ same as we did in Needleman-Wunsh algorithm. 

TODO výpočet $A$.

Finally we will find warping path in $A$ by following lowest values from $A[n,m]$ to $A[1,1]$. 
TODO vysvetliť.

The complexity of this implementation is quadratic, but can be simply reduced to almost linear by restricting area where warping path can be to a band with constant width. We will define $c(i,j)=-\infty$ for all $i,j$ not in the belt. This way we will easily see if this belt does not cover whole warping path by checking if the value of chosen point is finite while constructing warping path. 
When belt is not wide enough, we will restart computation with twice as wide belt.
\begin{figure}
  \centering
  TODO
  %\includegraphics[width=0.5\textwidth]{gull}
  \caption{obrazok vymedzeného pásu.}
\end{figure}


\subsection{Signal reconstruction from warping path}
To create one signal out of two, we will use the warping path created by DTW.
Altough the signals are very similar, alignment still contains some insertions in both ways. 

\begin{figure}
  \centering
  TODO
  %\includegraphics[width=0.5\textwidth]{gull}
  \caption{dva grafi lignalov pod sebov s čiarami medzi zarovnanými bodmy.}
\end{figure}

When aligning DNA sequences, we had three posibilities. Match, mismatch or aligned to dash. 
This time, we have full pairing of points. Each point from first sequence have the corresponding point
in second sequence. This also means, that sometimes one point from one sequence corresponds to multiple 
points from the other sequence.
We considered multiple ways to solve this problem and compared them.

First approach was to calculate average of each pair of points and concat them to final signal. The signal we created
was slightli longer, and not what basecaller expect.

Second approach was to take first sequence as leading, and construct final signal by calculating average of point from this sequence and all points aligned to it, in every point of this sequence. This approach puts a high tension on first sequence.
If some part is missing, and it alignes to one point, it will still miss. Same if some part is longer than should, one point will align to it, and it will stay there. Advantage is, that it looks exactly like signal that basecaller expect.

\subsection{Multiple alignment}

To align multiple signals, we chosen iterative method as signals are much longer than DNA sequencies and iterative method is faster.

If we would just iteratively add ...

First approach was to calculate weighted average when aligning $i$-th signal to consensus of $i-1$ already aligned signals. 
Result is that in each point, every sequence have same weight.

Second approach was to improve first one, by remembering how many points were aligned from all sequences to each point. We used
this information when reconstructing final signal. For each point we calculated average number of point aligned to it, and put it that many times to final sequence.

This approach was better in some cases, but worse in other cases. It maight be coused because we have still used first sequence as leading, so no missing part could be added.

With this different way of reconstructing final sequence, we can afford to take full alignment each time. 
It will result in much longer signal than expected, which will be later reduced by realigning all sequences to it and counting 
points aligned to each point.